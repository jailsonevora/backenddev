<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Document Archives - Backend-Dev</title>
	<atom:link href="https://jailsonevora.com/tag/document/feed/" rel="self" type="application/rss+xml" />
	<link>https://jailsonevora.com/tag/document/</link>
	<description>Backend development blog</description>
	<lastBuildDate>Sun, 02 Jul 2023 23:19:37 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.2</generator>

<image>
	<url>https://jailsonevora.com/wp-content/uploads/2023/06/cropped-1678234464025-32x32.jpg</url>
	<title>Document Archives - Backend-Dev</title>
	<link>https://jailsonevora.com/tag/document/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Strategies for Scaling Databases</title>
		<link>https://jailsonevora.com/2023/07/02/strategies-for-scaling-databases/</link>
					<comments>https://jailsonevora.com/2023/07/02/strategies-for-scaling-databases/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Sun, 02 Jul 2023 23:17:33 +0000</pubDate>
				<category><![CDATA[Software Architecture]]></category>
		<category><![CDATA[Software Design]]></category>
		<category><![CDATA[Cache eviction]]></category>
		<category><![CDATA[Cache invalidation]]></category>
		<category><![CDATA[Caching]]></category>
		<category><![CDATA[Caching aside]]></category>
		<category><![CDATA[Column-oriented]]></category>
		<category><![CDATA[DBMS]]></category>
		<category><![CDATA[Document]]></category>
		<category><![CDATA[Graph]]></category>
		<category><![CDATA[Horizontal Sharding]]></category>
		<category><![CDATA[Indexing]]></category>
		<category><![CDATA[Key-Value]]></category>
		<category><![CDATA[NoSQL]]></category>
		<category><![CDATA[Read-through]]></category>
		<category><![CDATA[Relational Database]]></category>
		<category><![CDATA[Replication]]></category>
		<category><![CDATA[Scaling]]></category>
		<category><![CDATA[Sharding]]></category>
		<category><![CDATA[TTL]]></category>
		<category><![CDATA[Vertical Sharding]]></category>
		<category><![CDATA[Write-back]]></category>
		<category><![CDATA[Write-through]]></category>
		<guid isPermaLink="false">https://jailsonevora.com/?p=2929</guid>

					<description><![CDATA[<p>Different solutions for scaling databases</p>
<p>The post <a rel="nofollow" href="https://jailsonevora.com/2023/07/02/strategies-for-scaling-databases/">Strategies for Scaling Databases</a> appeared first on <a rel="nofollow" href="http://jailsonevora.com/">Backend-Dev</a>.</p>
]]></description>
										<content:encoded><![CDATA[
<p>Knowing the different techniques for scaling databases, help us to choose the appropriate strategy to adapt to our needs and propose.</p>



<p>Hence, in this post, we will demonstrate different solutions and techniques for scaling databases server.  They are divided between reading and writing strategies.</p>



<h2 class="wp-block-heading">Scaling databases &#8211; Reading/Loading</h2>



<p>Sometimes we have applications that are under so much <a href="https://jailsonevora.com/2019/09/16/key-java-annotations-to-build-spring-boot-rest-api/" target="_blank" rel="noreferrer noopener">load</a>. And to deal with this issue, we demostrate three different <a href="https://jailsonevora.com/2019/08/10/java-ee/" target="_blank" rel="noreferrer noopener">techniques </a>that we can implement. </p>



<h3 class="wp-block-heading">Caching for scaling databases</h3>



<p>Caching technique stores frequently requested data or expensive computing operations responses in temporary memory. The data stored in the cache needs to be changed by the nature of the application, and to update them, the cache <strong>invalidation and eviction</strong> technique can be used to maintain the consistency of the data. It can be achieved with the cache expired time to live (<strong>TTL</strong>) method or others dependent on the caching patterns used.</p>



<p>There are also different caching patterns that can be used as a strategy to implement caching solutions. <strong>Caching aside </strong>supports heavy reads and works even if the cache goes down. <strong>Read-through </strong>and <strong>Write-through</strong> are used together. They are great alternatives for read-heavy workloads but cache failure results in system failure. The last one is <strong>Write-back </strong>useful for writing heavy workloads, and used by various DBMS implementations.</p>



<figure class="wp-block-image aligncenter is-resized"><img decoding="async" src="https://documents.lucid.app/documents/5f2ed513-1fa5-4d6e-91bd-b7f69e3433e3/pages/0_0?a=1757&amp;x=-464&amp;y=2197&amp;w=967&amp;h=444&amp;store=1&amp;accept=image%2F*&amp;auth=LCA%20cc33cf943beff34aa1a6e56ca3c8228b33a0eaa1862c62d5cc5779666b82e332-ts%3D1688291822" alt="Scaling Databases Database caching" width="723" height="333"/><figcaption class="wp-element-caption">Database caching</figcaption></figure>



<p>Depending on the requirements such as heavy reading or heavy writing or a mix of both, we can decide which pattern to use in a way that we can afford cache or database failure.</p>



<h3 class="wp-block-heading">Replication for scaling databases</h3>



<p>Repplicattion basically works with having one database referred to as <strong>main</strong> where all the writing request flow to it. In addition, we make an exact copy of that main database as new node replicas known as <strong>secondary, </strong>responsible only for dealing with the reading requests. The main database constantly feeds the slaves nodes with more recent data keeping our information consistent between all the nodes in the cluster. </p>



<p>Replication is a great strategy to deal with fault tolerance and maintain the CAP theorem and system scalability. Suppose one of the nodes goes down we continue to server as we have the same data replicated in the other nodes. Also in a cluster, a node can take over and become a main database in case of failure of the primary node. Replication also helps reduce latency in our application, once we can have our database deployed and data replicated on different regions such as <a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noreferrer noopener">CDN</a>, it can be accessed easily by the local users.</p>



<figure class="wp-block-image aligncenter is-resized"><img decoding="async" loading="lazy" src="https://documents.lucid.app/documents/5f2ed513-1fa5-4d6e-91bd-b7f69e3433e3/pages/0_0?a=1602&amp;x=-314&amp;y=1336&amp;w=747&amp;h=528&amp;store=1&amp;accept=image%2F*&amp;auth=LCA%2062b5a257e06bc3e4a98457d2a2f2a475e428f0a6c74f2bb5bff089c27c6a12a6-ts%3D1688291822" alt="Scaling Databases Database replication technique" width="560" height="396"/><figcaption class="wp-element-caption">Database replication technique</figcaption></figure>



<p>Besides those advantages, maintaining consistency in the replica node became complicated with the increase of the nodes.  This problem can be solved using a <strong>synchronous </strong>or <strong>asynchronous </strong>replication strategy depending on the requirements.</p>



<p>The synchronous strategy has the advantage of the <strong><em>lag is zero</em></strong>, and the data is always consistent. but as a downside, the performance is affected once it is necessary to wait till all the replicas are updated and acknowledged by the issuer. On the other hand, in the asynchronous strategy, the writes became faster as the main node does not wait for the acknowledgment but rise the problem of an inconsistent state if a replica fails to update the value.</p>



<p>Bear in mind that there is no silver bullet, the best strategy depends on our needs. A trade-off must be assumed between consistency, availability, or partition (CAP Theorem). The CAP theorem state that we can guarantee only two of them at a time.</p>



<h3 class="wp-block-heading">Indexing for scaling databases</h3>



<p>Indexing is used to locate and quickly access data, improve the performance of database activity. A database table can have one or more indexes associated with it.</p>



<p>Indexing improve query performance with faster data retrieval, it enhance data acces efficiency decreasing the number of I/O for retrieve the data. It optimize data sorting since the database does not need to sorting the entire table and instead only the relevant rows. Indexing maintain the data consistent even with the rise of amount of data. Also, indexing ensure the database integrity, avoiding storing duplicated data.</p>



<figure class="wp-block-image aligncenter size-full"><img decoding="async" loading="lazy" width="326" height="218" src="https://jailsonevora.com/wp-content/uploads/2023/07/image-5.png" alt="" class="wp-image-2971" srcset="https://jailsonevora.com/wp-content/uploads/2023/07/image-5.png 326w, https://jailsonevora.com/wp-content/uploads/2023/07/image-5-300x201.png 300w" sizes="(max-width: 326px) 100vw, 326px" /></figure>



<p>As drawback, indexing needs more storage which increases the database size. It also increase the mantaince overhead with addition, removal and modifications in the table. Indenxing can reduce perfomace in insert and update. Chosing an index can be difficult for a specific query or application.</p>



<h2 class="wp-block-heading">Scaling Databases &#8211; Writing</h2>



<p>For applications that have a lot of writing to the database with the users constantly harming it with new data, we have sharding and NoSQL solutions.</p>



<h3 class="wp-block-heading">Database Sharding for scaling databases</h3>



<p>Sharding or data partition allows the separation of large databases data into smaller, faster, more easily managed parts, splitting the database into multiple main databases. There are two kinds of sharding, <strong>vertical</strong> and <strong>horizontal</strong>.</p>



<p>The data partition has the advantage of query optimization bringing a better performance and reducing latency. It allows the possibility to have users&#8217; data across different locations that can be accessed faster for users in particular regions. Also, it has the advantage of avoiding a single point o failure.</p>



<p>One of the drawbacks of sharding is partition overloaded in case we did not distribute the data across the partition correctly. Depending on the strategy we choose, we can end up with some partitions with a lot of data and some with fewer data, and the query on that large partition can become slower. Another disadvantage is to come back and recover the prior state of the no-sharding strategy once it was implemented and the data split across different databases.</p>



<p>The application of partition can be logical or physical. A logical sharding is when we have a different subset of the data in the same physical machine, otherwise, a physical sharding can have more than one subset of the partition.</p>



<p>For partitioning the data we can choose between algorithm sharding or dynamic sharding. There exist different algorithms and dynamic sharding technics, key-based, range-based, and directory-based sharding are the most used.</p>



<h4 class="wp-block-heading">Vertical sharding</h4>



<p>We take each table and we put them on a different machine. Such as user tables, log tables, or comment tables, each on different machines. Vertical sharding is effective when queries tend to return only a subset of columns of the data. For example, if some queries request only names, and others request only addresses, then the names and addresses can be sharded onto separate servers.</p>



<figure class="wp-block-image aligncenter is-resized"><img decoding="async" loading="lazy" src="https://documents.lucid.app/documents/277d215c-f0a3-4a28-ae60-66c3c69505e6/pages/0_0?a=771&amp;x=225&amp;y=-693&amp;w=1215&amp;h=1166&amp;store=1&amp;accept=image%2F*&amp;auth=LCA%20fb27ba4f300f942027f6cb5a7cba40202875a1d57f4920dd1dd1ffec951d41e9-ts%3D1688312868" alt="Scaling Databases Vertical sharding" width="608" height="583"/><figcaption class="wp-element-caption">Vertical sharding</figcaption></figure>



<h4 class="wp-block-heading">Horizontal sharding</h4>



<p>In case we have a single table that is became very large, we apply horizontal sharding. We take a single table and we split that table across multiple machines. Horizontal sharding is effective when queries tend to return a subset of rows that are often grouped together. For example, queries that filter data based on short date ranges are ideal for horizontal sharding since the date range will necessarily limit querying to only a subset of the servers.</p>



<figure class="wp-block-image aligncenter is-resized"><img decoding="async" loading="lazy" src="https://documents.lucid.app/documents/cb19946c-e312-4df4-9912-e5fa677fd39f/pages/0_0?a=281&amp;x=-419&amp;y=-228&amp;w=1738&amp;h=1057&amp;store=1&amp;accept=image%2F*&amp;auth=LCA%20b4f87973d8c846c410b55803e5402d5837b6da85bb6fe776185b116d883a3f4b-ts%3D1688299021" alt="Horizontal sharding" width="869" height="529"/><figcaption class="wp-element-caption">Horizontal sharding</figcaption></figure>



<h3 class="wp-block-heading">No SQL for Scaling Database</h3>



<p>No SQl is not realtional database and essentially is key-value pairs. A key-value pair models are natural able to scales easily by themselves across multiple different machines. NoSQL are classified into four main categories, <strong>Column-oriented</strong> that stores data as column families, <strong>Graph </strong>stores data as nodes and edges, <strong>Key-Value</strong> stores data as key-value pairs and <strong>Document </strong>that stores data as semi-strutured documents. </p>



<figure class="wp-block-image aligncenter is-resized"><img decoding="async" loading="lazy" src="https://documents.lucid.app/documents/5f2ed513-1fa5-4d6e-91bd-b7f69e3433e3/pages/0_0?a=563&amp;x=-549&amp;y=108&amp;w=1078&amp;h=1144&amp;store=1&amp;accept=image%2F*&amp;auth=LCA%201b0fc458cc8da4c839c83deded43ac4c6e6d72728d1b5d716317f0cc236d22f1-ts%3D1688291822" alt="Scaling Databases NoSQL database categories" width="787" height="858"/><figcaption class="wp-element-caption">NoSQL database categories</figcaption></figure>



<p>NoSQL allows <strong>dyniming schema</strong> which can accomodate changes without schema alterations. Also it provide <strong>horizontal scalability</strong> since it was designed to scale out by adding more nodes to a database cluster. It is also designed for <strong>highly availability</strong> to handle node failues automatically and data replication acrros multiple nodes int the cluster.</p>



<p>It offers several benefits over relational databases, such as scalability, flexibility, and cost-effectiveness. However, they also have several drawbacks, such as a lack of standardization, lack of ACID compliance, and lack of support for complex queries.</p>



<p> </p>



<h2 class="wp-block-heading">Conclusion</h2>



<p>Scaling databases</p>
<p>The post <a rel="nofollow" href="https://jailsonevora.com/2023/07/02/strategies-for-scaling-databases/">Strategies for Scaling Databases</a> appeared first on <a rel="nofollow" href="http://jailsonevora.com/">Backend-Dev</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://jailsonevora.com/2023/07/02/strategies-for-scaling-databases/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>

<!--
Performance optimized by W3 Total Cache. Learn more: https://www.boldgrid.com/w3-total-cache/

Object Caching 66/72 objects using disk
Page Caching using disk: enhanced (Page is feed) 
Content Delivery Network via N/A
Lazy Loading (feed)
Database Caching 5/8 queries in 0.013 seconds using disk

Served from: localhost @ 2023-07-03 00:40:04 by W3 Total Cache
-->